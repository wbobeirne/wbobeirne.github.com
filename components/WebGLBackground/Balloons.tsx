/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import {
  NearestFilter,
  Vector3,
  Mesh,
  MeshToonMaterial,
  Texture,
  RepeatWrapping,
} from "three";
import { useFrame } from "@react-three/fiber";

type GLTFResult = GLTF & {
  nodes: {
    Hot_Air_Balloon: THREE.Mesh;
  };
  materials: {
    ["Material.001"]: THREE.MeshStandardMaterial;
  };
};

const balloonScale = new Vector3(0.026, 0.02, 0.026);
const makeBalloon = ({
  x,
  y,
  scale,
  opacity,
  textureX,
  textureY,
}: {
  x: number;
  y: number;
  scale: number;
  opacity: number;
  textureX: number;
  textureY: number;
}) => ({
  position: new Vector3(x - 1.5, y, 30 - scale * 10),
  scale: new Vector3().copy(balloonScale).multiplyScalar(scale),
  speed: Math.random(),
  opacity,
  textureX,
  textureY,
});
const balloons = [
  makeBalloon({
    x: 4,
    y: 7.58,
    scale: 0.3,
    opacity: 0.5,
    textureX: 0.5,
    textureY: 0.25,
  }),
  makeBalloon({
    x: 3.5,
    y: 6.2,
    scale: 0.5,
    opacity: 0.6,
    textureX: 0,
    textureY: 0.5,
  }),
  makeBalloon({
    x: 2.5,
    y: 5.58,
    scale: 0.7,
    opacity: 0.8,
    textureX: 0.5,
    textureY: 0,
  }),
  makeBalloon({
    x: 1.5,
    y: 5.8,
    scale: 0.9,
    opacity: 0.9,
    textureX: 0.25,
    textureY: 0,
  }),
  makeBalloon({
    x: 0,
    y: 4.58,
    scale: 1.2,
    opacity: 0.95,
    textureX: 0,
    textureY: 0,
  }),
  makeBalloon({
    x: -2,
    y: 5.68,
    scale: 1.5,
    opacity: 1,
    textureX: 0.25,
    textureY: 0.25,
  }),
];

interface BalloonsProps {
  show: boolean;
}

export const Balloons: React.FC<BalloonsProps> = ({ show }) => {
  const meshRefs = useRef<Mesh[]>([]);
  const visibilityRef = useRef({ visible: false, time: Date.now() });

  useEffect(() => {
    const timeout = setTimeout(
      () => {
        visibilityRef.current = { visible: show, time: Date.now() };
      },
      show ? 800 : 600,
    );
    return () => clearTimeout(timeout);
  }, [show]);

  const { nodes } = useGLTF("/threejs/models/balloon2.glb") as GLTFResult;
  const textures = useTexture(
    balloons.map(() => "/threejs/textures/balloons.png"),
    (txs) => {
      (txs as Texture[]).forEach((t, i) => {
        const balloon = balloons[i];
        t.offset.set(balloon.textureX, balloon.textureY);
        t.repeat.set(0.25, 0.25);
        t.wrapS = RepeatWrapping;
        t.wrapT = RepeatWrapping;
        t.minFilter = NearestFilter;
        t.magFilter = NearestFilter;
        t.flipY = false;
      });
    },
  );
  const balloonNode = nodes.Hot_Air_Balloon;

  useFrame(({ clock }) => {
    const t = clock.getElapsedTime();
    const now = Date.now();
    const visState = visibilityRef.current;
    const len = meshRefs.current?.length || 0;
    meshRefs.current?.forEach((mesh, i) => {
      const vis = visState.visible
        ? calculateBalloonVisibility(visState.time, now, len - i - 1)
        : 0;
      const balloon = balloons[i];
      const risingYOffset = Math.sin(((1 - vis) * 0.7 * Math.PI) / 2);
      const floatingYOffset = Math.sin((t + i * 0.2) * balloon.speed) * 0.1;
      mesh.position.y = balloon.position.y - risingYOffset - floatingYOffset;

      const floatingYRotate =
        Math.PI * Math.sin((t + i * 0.5) * balloon.speed) * 0.04;
      mesh.rotation.y = floatingYRotate;

      const material = mesh.material as MeshToonMaterial;
      material.opacity = Math.min(1, balloon.opacity * vis);
    });
  });

  return (
    <group>
      {balloons.map((balloon, i) => (
        <mesh
          ref={(r) => void (r ? (meshRefs.current[i] = r) : undefined)}
          key={i}
          geometry={balloonNode.geometry}
          position={balloon.position}
          scale={balloon.scale}
        >
          <meshToonMaterial map={textures[i]} transparent />
        </mesh>
      ))}
    </group>
  );
};

const BALLOON_DURATION = 3000;
const BALLOON_DECAY = 400;
const BALLOON_OFFSET = 200;
const calculateBalloonVisibility = (
  visTime: number,
  now: number,
  i: number,
) => {
  const elapsed = now - BALLOON_OFFSET * i - visTime;
  const duration = BALLOON_DURATION + BALLOON_DECAY * i;
  const progress = Math.min(1, elapsed / duration);
  return 1 - Math.pow(1 - progress, 5);
};
