/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { NearestFilter, Vector3, Mesh, MeshToonMaterial } from "three";
import { useSpring } from "framer-motion";
import { useFrame } from "@react-three/fiber";

type GLTFResult = GLTF & {
  nodes: {
    Hot_Air_Balloon: THREE.Mesh;
  };
  materials: {
    ["Material.001"]: THREE.MeshStandardMaterial;
  };
};

const balloonScale = new Vector3(0.026, 0.02, 0.026);
const makeBalloon = (x: number, y: number, scale: number) => ({
  position: new Vector3(x, y, 30 - scale * 10),
  scale: new Vector3().copy(balloonScale).multiplyScalar(scale),
  opacity: Math.min(1, scale),
  speed: Math.random(),
});
const balloons = [
  makeBalloon(4, 7.58, 0.3),
  makeBalloon(3.5, 6.2, 0.5),
  makeBalloon(2.8, 6.58, 0.4),
  makeBalloon(2.5, 5.58, 0.7),
  makeBalloon(1.5, 5.8, 0.9),
  makeBalloon(0, 4.58, 1.2),
  makeBalloon(-2, 5.68, 1.5),
];

interface BalloonsProps {
  show: boolean;
}

export const Balloons: React.FC<BalloonsProps> = ({ show }) => {
  const meshRefs = useRef<Mesh[]>([]);
  const visibilitySprings = balloons.map((_, i) =>
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useSpring(0.0, { duration: 3000 - 300 * i })
  );

  useEffect(() => {
    if (!show) {
      // Instantly reset visibility after a delay. Not a part of the official API.
      const timeout = setTimeout(
        () => visibilitySprings.forEach((s) => ((s as any).current = 0.0)),
        600
      );
      return () => clearTimeout(timeout);
    } else {
      const timeouts = visibilitySprings.map((s, i) =>
        setTimeout(
          () => s.set(1.0),
          visibilitySprings.length * 100 - i * 100 + 600
        )
      );
      return () => timeouts.forEach(clearTimeout);
    }
  }, [show, visibilitySprings]);

  const { nodes, materials } = useGLTF(
    "/threejs/models/balloon.glb"
  ) as GLTFResult;
  const balloonNode = nodes.Hot_Air_Balloon;
  const material = materials["Material.001"];

  useEffect(() => {
    if (!material || !material.map) return;
    material.map.minFilter = NearestFilter;
    material.map.magFilter = NearestFilter;
  }, [material]);

  useFrame(({ clock }) => {
    const t = clock.getElapsedTime();
    meshRefs.current?.forEach((mesh, i) => {
      const vis = visibilitySprings[i].get();
      const balloon = balloons[i];
      const risingYOffset = (1 - vis) * 0.7;
      const floatingYOffset = Math.sin((t + i * 0.2) * balloon.speed) * 0.1;
      mesh.position.y = balloon.position.y - risingYOffset - floatingYOffset;

      const floatingYRotate =
        Math.PI * Math.sin((t + i * 0.5) * balloon.speed) * 0.04;
      mesh.rotation.y = floatingYRotate;

      const material = mesh.material as MeshToonMaterial;
      console.log(i, balloon.opacity * vis);
      material.opacity = balloon.opacity * vis;
    });
  });

  return (
    <group>
      {balloons.map((balloon, i) => (
        <mesh
          ref={(r) => (r ? (meshRefs.current[i] = r) : undefined)}
          key={i}
          geometry={balloonNode.geometry}
          position={balloon.position}
          scale={balloon.scale}
        >
          <meshToonMaterial map={material.map} transparent />
        </mesh>
      ))}
    </group>
  );
};

useGLTF.preload("/balloon.glb");
