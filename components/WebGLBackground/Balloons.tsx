/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { NearestFilter, Vector3, Mesh, MeshToonMaterial, Texture } from "three";
import { useFrame } from "@react-three/fiber";
import { optimizedTexturePath } from "../../util/image";

import BalloonSunrise from "../../public/threejs/textures/balloon-sunrise.png";
import BalloonDiamonds from "../../public/threejs/textures/balloon-diamonds.png";
import BalloonDiagonal from "../../public/threejs/textures/balloon-diagonal.png";
import BalloonCheckers from "../../public/threejs/textures/balloon-checkers.png";
import BalloonBands from "../../public/threejs/textures/balloon-bands.png";
import BalloonStripe from "../../public/threejs/textures/balloon-stripe.png";

type GLTFResult = GLTF & {
  nodes: {
    Hot_Air_Balloon: THREE.Mesh;
  };
  materials: {
    ["Material.001"]: THREE.MeshStandardMaterial;
  };
};

const balloonScale = new Vector3(0.026, 0.02, 0.026);
const makeBalloon = (x: number, y: number, scale: number, opacity: number) => ({
  position: new Vector3(x, y, 30 - scale * 10),
  scale: new Vector3().copy(balloonScale).multiplyScalar(scale),
  speed: Math.random(),
  opacity,
});
const balloons = [
  makeBalloon(4, 7.58, 0.3, 0.5),
  makeBalloon(3.5, 6.2, 0.5, 0.6),
  makeBalloon(2.5, 5.58, 0.7, 0.8),
  makeBalloon(1.5, 5.8, 0.9, 0.9),
  makeBalloon(0, 4.58, 1.2, 0.95),
  makeBalloon(-2, 5.68, 1.5, 1),
];

interface BalloonsProps {
  show: boolean;
}

export const Balloons: React.FC<BalloonsProps> = ({ show }) => {
  const meshRefs = useRef<Mesh[]>([]);
  const visibilityRef = useRef({ visible: false, time: Date.now() });

  useEffect(() => {
    const timeout = setTimeout(
      () => {
        visibilityRef.current = { visible: show, time: Date.now() };
      },
      show ? 800 : 600
    );
    return () => clearTimeout(timeout);
  }, [show]);

  const { nodes } = useGLTF("/threejs/models/balloon2.glb") as GLTFResult;
  const textures = useTexture(
    [
      optimizedTexturePath(BalloonSunrise),
      optimizedTexturePath(BalloonDiamonds),
      optimizedTexturePath(BalloonDiagonal),
      optimizedTexturePath(BalloonCheckers),
      optimizedTexturePath(BalloonBands),
      optimizedTexturePath(BalloonStripe),
    ],
    (txs) => {
      (txs as Texture[]).forEach((tx) => {
        tx.minFilter = NearestFilter;
        tx.magFilter = NearestFilter;
        tx.flipY = false;
      });
    }
  );
  const balloonNode = nodes.Hot_Air_Balloon;

  useFrame(({ clock }) => {
    const t = clock.getElapsedTime();
    const now = Date.now();
    const visState = visibilityRef.current;
    const len = meshRefs.current?.length || 0;
    meshRefs.current?.forEach((mesh, i) => {
      const vis = visState.visible
        ? calculateBalloonVisibility(visState.time, now, len - i - 1)
        : 0;
      const balloon = balloons[i];
      const risingYOffset = Math.sin(((1 - vis) * 0.7 * Math.PI) / 2);
      const floatingYOffset = Math.sin((t + i * 0.2) * balloon.speed) * 0.1;
      mesh.position.y = balloon.position.y - risingYOffset - floatingYOffset;

      const floatingYRotate =
        Math.PI * Math.sin((t + i * 0.5) * balloon.speed) * 0.04;
      mesh.rotation.y = floatingYRotate;

      const material = mesh.material as MeshToonMaterial;
      material.opacity = Math.min(1, balloon.opacity * vis);
    });
  });

  return (
    <group>
      {balloons.map((balloon, i) => (
        <mesh
          ref={(r) => (r ? (meshRefs.current[i] = r) : undefined)}
          key={i}
          geometry={balloonNode.geometry}
          position={balloon.position}
          scale={balloon.scale}
        >
          <meshToonMaterial map={textures[i]} transparent />
        </mesh>
      ))}
    </group>
  );
};

const BALLOON_DURATION = 3000;
const BALLOON_DECAY = 400;
const BALLOON_OFFSET = 200;
const calculateBalloonVisibility = (
  visTime: number,
  now: number,
  i: number
) => {
  const elapsed = now - BALLOON_OFFSET * i - visTime;
  const duration = BALLOON_DURATION + BALLOON_DECAY * i;
  const progress = Math.min(1, elapsed / duration);
  return 1 - Math.pow(1 - progress, 5);
};
